док: Модели и метрики

## Модели метрики оценки качества

Хар-ется: сложно найти универсальные модели метрики оценки качества ПО, как правило их применимость зависит от области использования ПО, их типов, этапа жизненного цикла программных средств(ЖЦПС) на котором производится процесс и ряд других факторов, т.е. универсальных не существует.

Существует ряд моделей и метрик, которые неплохо зарекомендовали себя на практике. И все эти модели и метрики можно разделить на три большие группы: 1. метрики сложности; 2. модели для прогнозирования; 3. оценочные модели.

## Модели сложности

Рассматриваются 3 аспекта классификации метрик сложности: 1. по категориям (словарные метрики, метрики связей, семантические метрики); 2. сложность проектирования, сложность функционирования; 3. когда исп. топологические метрики сложности.

Словарные метрики - основаны на метрических отношениях Холстеда (длина программы, объем, трудность понимания и т.д.).

Метрики связей - отражают отношение между компонентами системы. Метрики Уина и Винчестера.

Семантические метрики - связаны с архитектурным построением программ и их оформлением.

Сложность проектирования - размеры программ, количество обрабатываемых переменных, трудоемкость, длительность разработки. Анализируется сложность структуры программы, сложность алгоритмов, сложность данных.

Сложность функционирования - временная сложность, программная и информационная, которая эксплуатационных качеств.

Когда исп. топологические метрики сложности - когда исп. граф.

## Документация

Все документы делятся на две большие группы:

1. Документы связанные с управлением разработки ПС (документация, которая сопровождает проект, software process documentation) - нужны для управления протоколирования на жизненном цикле программных средств. (Планы, оценки и расписания; отчеты об использовании *чего-то*; нормативные документы; рабочие документы(фиксация проблем, задач); заметка и переписка.) 
2. Документы входящие в состав (software product documentation, ). Описывает ПС, с точки зрения пользователей и разработчиков. Делится на 2 категории: 1. Пользовательская(П) документация. 2. Документация по сопровождению(С).

2.1. (User documentation) общее функциональное описание программных средств, руководство по инсталяции, инструкции по применению, справочники по применению, руководство по ...

2.2. (System documentation) Делиться на 2 группы: 1. документация определяющая строение программы, структур данных, технологию разработки; 2. документация помогающая вносить изменения в ПС.

2.2.1. Внешние описание программного средства(тех задание), описание архитектуры ПС(), описание модульной системы или компонентов, заголовки модулей и описание строения модулей, сам программный код, разные тесты для проверки работоспособности.

2.2.2. Руководство по сопровождению(особенности реализации).

 

## Отладка и тестирование

Отладка - процесс, позволяющий получить программу, которая при выполнении на заданной области входных данных отвечает заданным требованиям.

Включает 3 этапа: 1.тестирование; 2.определение характера ошибок и их местоположение; 3.внесение исправлений в программу, с целью исправления ошибок.

Тестирование - любая деятельность направленная на выявление ошибок ПО.

Отладка может занимать до 50% времени разработки.

90% времени при отладке тратится на нахождение ошибок.

## Тестирование

это любая деятельность направленная на обнаружение ошибок ПО.

рекомендации (ПонятияОтладкаТестрирование.doc)

20:80 , психологическое расстояние

## Общий анализ методов тестирования

различают 4 основных подхода к тестированию: 1.статическое тестирование (ручные методые тестирования, тестирование за столом); 2.детерминированное тестирование (исполнение тестов на пк); 3.стохастическое тестирование; 4.тестирование в реальном времени.

## Статические методы тестирования

2 подхода: 1.испекция исходного текста; 2.сквозной просмотр.

общий принцип, на котором основывается данный метод: собирается собрание состоящее из неск. участников, ставит себе целью найти ошибки, в собрание входят как правило: опытный тестировщик, автор и прочие.

1. По составу комиссии: проектировщик, автор, специалист по тестированию.

комиссия проверяет текст программы по заранее подготовленным вопросам. (Вопросы для испекции.doc)

2. Специалист по тестированию готовит тесты логики программы. прогоняются мысленно и результат фиксируется.

## Детерминированное тестирование

2 подхода: 1.структурное  тестирование (по принципу белого ящика); 2.функциональное тестирование (по принципу черного ящика).

1. проверяем логику программы, при этом зная её структуру.
2. абстрагируемся, тестовые наборы формируются на основе спецификации программы.

## Стохастическое тестирование

Примеряется при: когда исходные данные представляют собой промежуток все значения, из которого невозможно перебрать обычным перебором.

При помощи датчика случайных чисел на заданном промежутке генерируют выборку. Т.к. на выборке программа отработала корректно, то с определенной вероятностью наша программа работает корректно.

## Тестирование в реальном времени

когда применяется: когда необходимо обрабатывать данные с учетом времени их поступления.

Учитывается: длительность обработки, приоритетность обработки, динамика использования памяти, взаимодействие с другими программами.

При обнаружении ошибки время фиксируется, ситуация и переход к детерминированным методам тестирования.



## Детерминированные методы тестирования

Детерминированное  тестирование .doc

при детерминированном тестировании происходит многократное повторение программы, с использованием специально подобранных наборов тестов.

эффективный тестовый набор - называют такое подмножество всех тестов, которое имеет наивысшую вероятность обнаружения большинства ошибок.(граф)



## Структурное тестирование

тестирование по принципу белого ящика

4 основных критерия для построения тестовых наборов данных:

1. покрытие операторов (самый слабый) условный оператор вызывается хотя бы 1 раз, при этом не важно по какому условию он идет (ложь\правда)
2. покрытия узлов ветвления (покрытие решений) в каждом условии был переход по обоим веткам хотя бы раз.
3. покрытие условий (если узел ветвления содержит более одного условия) 1. тест проектируется так, чтобы результаты каждого условия выполнялись хотя бы 1 раз; 2. в точке входа в программу управление должно быть передано хотя бы 1 раз.
4. комбинаторное покрытие условий () проверяются все возможные комбинации результатов условия и все точки входа выполнялись хотя бы 1 раз.



## Функциональное тестирование

тестирование по принципу черного ящика (анализируются входные и выходные спецификации)

Методы: 1. эквивалентное разбиение; 2. анализ граничных значений; 3. функциональная диаграмма.

1. Эквивалентное разбиение. Состоит из 2 этапов: 1. выделяем класс эквивалентности; 2. построение тестов.

   Класс эквивалентности - множество входных значений, каждая из которых имеет одинаковую вероятность обнаружения ошибок конкретного типа.

   правильный класс эквивалентности - входные данные.

   не правильный класс эквивалентности - ошибочные входные данные.

   | входные условия | правильные классы эквивалентности | неправильные классы эквивалентности |
   | --------------- | --------------------------------- | ----------------------------------- |
   |                 |                                   |                                     |

   Правила выделения классов:

   1. Если входное условие описывает область значений, то определяют один правильный класс эквивалентности и два неправильных. (прим. 1<количество символов метки<8)
   2. Если входное условие описывает конечное число конкретных значений, то для каждого значения определяется один правильный и один неправильный класс эквивалентности. (один правильный, один не правильный который в этот список не входит).
   3. Если входное условие описывает ситуацию "должно быть", то определяется один правильный и один не правильный класс эквивалентности. (прим. входное условие число: правильный - на вход число; не правильный - буква).

   на основе классов строятся тестовые наборы. для **правильных** классов стремятся к минимальному числу тестов (каждый тест должен покрывать как можно больше правильных классов). для каждого **неправильного** класса строится хотя бы 1 тестовый набор.

2. Анализ граничных значений. Исследует ситуации, возникающие на границах и вблизи границ эквивалентных разбиений. (прим. предусмотреть тесты выхода за левые и правые границы)
3. Функциональные диаграммы. Состоит из этапов:
   1. Исходная спецификация задачи. (строится). Причина - правильные входные данные(класс эквивалентности). Следствие - правильные выходные данные или результат преобразования. Выделяют из исходной спецификации причины и следствия и указывают им уникальный номер.
   2. Функциональная диаграмма. (строится). Преобразуем спецификацию в булевский граф, используя базовые символы и значки ограничений (табл. 1.). Для каждого следствия задается вопрос, когда оно возникает, в зависимости от ответа соединяются определенные вершины. Результат - граф.
   3. Таблица решений. (строится). Строится таблица решений по графу, заполняется верхняя часть причинами, нижняя следствиями. Каждое следствие устанавливается истина только 1 раз. Анализ начинается со следствия.
   4. Эффективный тестовый набор данных. (строится). Столбцы таблицы решений преобразуются в тесты. каждый столбец это 1 тест. 

